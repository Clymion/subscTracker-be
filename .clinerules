# Project Rules and Guidelines

## Basic Configuration

- **Language**: Python
- **Python Version**: 3.13
- **Max Line Length**: 100
- **Docstring Style**: Google

## Code Structure and Quality

### Type Hints

All functions and methods must use type hints for arguments and return values. Use built-in types for collections instead of typing.List.

```python
def get_subscription(subscription_id: str) -> dict:
    pass

def get_subscriptions_by_user(user_id: str) -> list[dict]:
    pass
```

### REST API Structure

Use Flask Blueprint to separate API endpoints by functionality. Follow RESTful design with appropriate HTTP methods.

```python
from flask import Blueprint, jsonify, request

subscription_bp = Blueprint('subscription', __name__, url_prefix='/api/v1/subscriptions')

@subscription_bp.route('/', methods=['GET'])
def get_subscriptions():
    # Implementation
    return jsonify(result), 200
```

### JWT Authentication

Implement authentication using flask-jwt-extended. Use @jwt_required() decorator for protected endpoints.

```python
from flask_jwt_extended import jwt_required, get_jwt_identity

@subscription_bp.route('/<subscription_id>', methods=['GET'])
@jwt_required()
def get_subscription(subscription_id: str):
    current_user = get_jwt_identity()
    # Implementation
    return jsonify(result), 200
```

### SQLAlchemy Models

Define SQLAlchemy models in separate files with type hints. Explicitly define relationships.

```python
from sqlalchemy import Column, String, Integer, ForeignKey, DateTime
from sqlalchemy.orm import relationship

from app.database import Base

class Subscription(Base):
    __tablename__ = 'subscriptions'
    
    id: str = Column(String(36), primary_key=True)
    name: str = Column(String(100), nullable=False)
    user_id: str = Column(String(36), ForeignKey('users.id'), nullable=False)
    created_at: datetime = Column(DateTime, nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="subscriptions")
```

### Error Handling

Define global error handlers and return standardized error responses. Create custom exception classes.

```python
from flask import jsonify

class APIError(Exception):
    def __init__(self, message: str, status_code: int):
        self.message = message
        self.status_code = status_code
        super().__init__(self.message)

@app.errorhandler(APIError)
def handle_api_error(error):
    response = jsonify({"error": error.message})
    response.status_code = error.status_code
    return response
```

## Test Driven Development

- Create a test list for each feature or API before implementation
- Implement detailed test cases using pytest
- Write tests first, then implement against them
- Follow test_*.py naming pattern

```python
# test_subscription_api.py
import pytest
from flask import Flask
from app import create_app

@pytest.fixture
def client():
    app = create_app('testing')
    with app.test_client() as client:
        yield client

def test_get_subscriptions(client):
    response = client.get('/api/v1/subscriptions/')
    assert response.status_code == 200
    data = response.get_json()
    assert isinstance(data, list)
```

## TDD Workflow

1. Before starting implementation, create a test list for each feature
2. Output test lists to `/docs/tests/` directory and seek confirmation
3. Implement tests based on confirmed test list
4. Write code to pass tests

## Project Structure

```
app/
├── api/
│   └── v1/
│       ├── auth.py
│       ├── subscription.py
│       └── settings.py
├── models/
│   ├── user.py
│   └── subscription.py
├── services/
│   ├── auth_service.py
│   └── subscription_service.py
└── schemas/
    ├── auth.py
    └── subscription.py
tests/
├── unit/
├── integration/
└── api/
docs/
├── openapi/        # OpenAPI specification
├── libraries/      # Generated markdown docs
├── db/             # Database definitions
│   └── table-definition.md
├── tests/          # Test lists for TDD
├── feature-list.md
├── MVP-proposal.md
└── system-proposal.md
migrations/
```

## Documentation

- **OpenAPI Definition**: Located at `/docs/openapi/`
- **DB Definition**: Located at `/docs/db/`
- **Test Lists**: Located at `/docs/tests/`

## Git Workflow

- **Workflow**: Gitflow
- **Branch Naming**:
  - `feature/{feature_name}`
  - `bugfix/{bug_name}`
  - `release/{version}`
  - `hotfix/{hotfix_name}`
- **Commit Message Format**: `{type}({scope}): {message}`
- **Commit Types**: feat, fix, docs, style, refactor, test, chore

## Dependencies

Use poetry for dependency management:
- **Dev**: pytest, pytest-cov, black, isort
- **Main**: flask, flask-jwt-extended, sqlalchemy, alembic, pydantic, python-dotenv, marshmallow

## Python Best Practices

- Always add typing annotations to all functions and classes
- Include return types for all functions
- Add descriptive docstrings following PEP 257
- Use pytest for all testing (not unittest)
- Create necessary `__init__.py` files
- Properly annotate test fixtures
- Follow modular design principles
- Implement robust error handling and logging
- Manage configuration via environment variables
- Use https://github.com/astral-sh/uv for dependency management
- Apply Ruff for code style consistency
